{"ast":null,"code":"import _classCallCheck from \"/Users/ke-vinhhoang/Documents/FinalProject/facerecognition/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/ke-vinhhoang/Documents/FinalProject/facerecognition/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/ke-vinhhoang/Documents/FinalProject/facerecognition/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/ke-vinhhoang/Documents/FinalProject/facerecognition/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/ke-vinhhoang/Documents/FinalProject/facerecognition/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/ke-vinhhoang/Documents/FinalProject/facerecognition/src/App.js\";\nimport React, { Component } from 'react';\nimport Particles from 'react-particles-js';\nimport Clarifai from 'clarifai';\nimport Navigation from './components/Navigation/Navigation';\nimport Rank from './components/Rank/Rank';\nimport ImageLinkForm from './components/ImageLinkForm/ImageLinkForm';\nimport FaceRecognition from './components/FaceRecognition/FaceRecognition';\nimport './App.css';\nvar app = new Clarifai.App({\n  apiKey: '39d724ef70ae41269091815b2c038508'\n});\nvar particlesOptions = {\n  particles: {\n    number: {\n      value: 100,\n      density: {\n        enable: true,\n        value_area: 800\n      }\n    },\n    size: {\n      enable: true,\n      value: 2\n    }\n  }\n};\n\nvar App =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(App, _Component);\n\n  function App() {\n    var _this;\n\n    _classCallCheck(this, App);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(App).call(this));\n\n    _this.calculateFaceLocation = function (data) {\n      // let boxArray = [];           // instead of creating a new array (because in order to use the map method, we need to have an array), we can simply set this.state.box: [] (an array) like above, however, if we decided to set this.state.box: {} (an object), then we'd have to create a new array to push it in in other to use the array loop methods\n      // if we tried to use the push method (like below), when this.state.box: {} (is an object) it wouldn't work because we need it to be an array to use the push method.\n      var clarifaiFace = data.outputs[0].data.regions;\n      var image = document.getElementById('inputimage');\n      var width = Number(image.width);\n      var height = Number(image.height); // console.log(width, height);\n      // the for of loop syntax is: for (variable of iterable) { statement } **iterables are arrays and strings (able to iterate over INDIVIDUAL items) so in this case 'data.outputs[0].data.regions' is an array \n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = clarifaiFace[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var face = _step.value;\n\n          _this.state.box.push({\n            bottomRow: height - face.region_info.bounding_box.bottom_row * height,\n            leftCol: face.region_info.bounding_box.left_col * width,\n            rightCol: width - face.region_info.bounding_box.right_col * width,\n            topRow: face.region_info.bounding_box.top_row * height\n          }); // here what we're doing is we are looping over each 'face' (items of the array) from the array 'const clarifaiFace' that it detects and pushes the value of the box (columns and rows) into the 'this.state.box' array so that later on in 'FaceRecognition.js' we can map over the array and have it generate the box (CSS lines).\n          // *** THE MAJOR FLAW RIGHT NOW: every time we click detect, it keeps pushing the values of the box into the this.state.box array, and it 'remembers' those values because it's in the same array that we later on, in 'FaceRecognition', map over to generate the box lines and so when we change URL (image), yes it will generate new boxes for the faces of the new picture, BUT it will also show the old boxes of the old faces of the old picture because the old values of the old boxes are still in the this.state.box array. \n          // so how do we make sure that every time we click detect, it's a fresh empty array that we're pushing the values in and mapping over to generate the face boxes?\n\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return _this.state.box; // after we looped and pushed the values of the box into the array 'this.state.box' (i.e. [0] (index 0) has bottomRow: 100, leftCol: 50, rightCol: 150, topRow: 200, then [1] ... for as many 'faces' as it detects) we want to return it\n    };\n\n    _this.displayFaceBox = function (boxValue) {\n      console.log(boxValue);\n\n      _this.setState({\n        box: boxValue\n      });\n    };\n\n    _this.onInputChange = function (event) {\n      _this.setState({\n        input: event.target.value\n      });\n    };\n\n    _this.onButtonSubmit = function () {\n      _this.setState({\n        imageUrl: _this.state.input\n      });\n\n      app.models.predict(Clarifai.DEMOGRAPHICS_MODEL, _this.state.input).then(function (response) {\n        return _this.displayFaceBox(_this.calculateFaceLocation(response));\n      }).catch(function (err) {\n        return console.log(err);\n      }); // .then(                         // check the breakdown of the nested object\n      //   function(response) {\n      //     console.log(response);\n      //   }\n      // )\n      // console.log('characteristics', response.outputs[0].data.regions[0].data.face);\n      // console.log('face box', response.outputs[0].data.regions[0].region_info.bounding_box);\n    };\n\n    _this.state = {\n      input: '',\n      imageUrl: '',\n      box: []\n    };\n    return _this;\n  }\n\n  _createClass(App, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", {\n        className: \"App\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 96\n        },\n        __self: this\n      }, React.createElement(Particles, {\n        className: \"particles\",\n        params: particlesOptions,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 97\n        },\n        __self: this\n      }), React.createElement(Navigation, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 100\n        },\n        __self: this\n      }), React.createElement(Rank, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 101\n        },\n        __self: this\n      }), React.createElement(ImageLinkForm, {\n        onInputChange: this.onInputChange,\n        onButtonSubmit: this.onButtonSubmit,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 102\n        },\n        __self: this\n      }), React.createElement(FaceRecognition, {\n        box: this.state.box,\n        imageUrl: this.state.imageUrl,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 106\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return App;\n}(Component); // all the yellow tags are 'components/child' of the parent 'App' and the purple tags (besides className) are 'props/data' that are passed down to child components \n// for example 'FaceRecognition' component has a 'box' prop which is {this.state.box}, in this case, the values that are passed are the values of the box (columns and rows) generated from the loop in calculateFaceLocation\n// so if we check the 'FaceRecognition' component\n\n\nexport default App; // (1) since onInputChange is a part of the 'App' class, to access it, we need to do 'this.onInputChange' because onInputChange is a property of the 'App'","map":{"version":3,"sources":["/Users/ke-vinhhoang/Documents/FinalProject/facerecognition/src/App.js"],"names":["React","Component","Particles","Clarifai","Navigation","Rank","ImageLinkForm","FaceRecognition","app","App","apiKey","particlesOptions","particles","number","value","density","enable","value_area","size","calculateFaceLocation","data","clarifaiFace","outputs","regions","image","document","getElementById","width","Number","height","face","state","box","push","bottomRow","region_info","bounding_box","bottom_row","leftCol","left_col","rightCol","right_col","topRow","top_row","displayFaceBox","boxValue","console","log","setState","onInputChange","event","input","target","onButtonSubmit","imageUrl","models","predict","DEMOGRAPHICS_MODEL","then","response","catch","err"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Particles from 'react-particles-js';\nimport Clarifai from 'clarifai';\nimport Navigation from './components/Navigation/Navigation';\nimport Rank from './components/Rank/Rank';\nimport ImageLinkForm from './components/ImageLinkForm/ImageLinkForm';\nimport FaceRecognition from './components/FaceRecognition/FaceRecognition';\nimport './App.css';\n\nconst app = new Clarifai.App({\n  apiKey: '39d724ef70ae41269091815b2c038508'\n });\n\nconst particlesOptions = {\n  particles: {\n    number: {\n      value: 100,\n      density: {\n        enable: true,\n        value_area: 800\n      }\n    },\n    size: {\n      enable: true,\n      value: 2\n    }\n  }\n}\n\nclass App extends Component {\n  constructor() {\n    super();\n    this.state = {\n      input: '',\n      imageUrl: '',\n      box: [],\n    }\n  }\n\n  calculateFaceLocation = (data) => {\n    // let boxArray = [];           // instead of creating a new array (because in order to use the map method, we need to have an array), we can simply set this.state.box: [] (an array) like above, however, if we decided to set this.state.box: {} (an object), then we'd have to create a new array to push it in in other to use the array loop methods\n      // if we tried to use the push method (like below), when this.state.box: {} (is an object) it wouldn't work because we need it to be an array to use the push method.\n\n    const clarifaiFace = data.outputs[0].data.regions;\n    const image = document.getElementById('inputimage');\n    const width = Number(image.width);\n    const height = Number(image.height);\n    // console.log(width, height);\n\n    // the for of loop syntax is: for (variable of iterable) { statement } **iterables are arrays and strings (able to iterate over INDIVIDUAL items) so in this case 'data.outputs[0].data.regions' is an array \n    for (const face of clarifaiFace) {\n      this.state.box.push({\n        bottomRow: height - (face.region_info.bounding_box.bottom_row * height),\n        leftCol: face.region_info.bounding_box.left_col * width,\n        rightCol: width - (face.region_info.bounding_box.right_col * width),\n        topRow: face.region_info.bounding_box.top_row * height\n      });\n    // here what we're doing is we are looping over each 'face' (items of the array) from the array 'const clarifaiFace' that it detects and pushes the value of the box (columns and rows) into the 'this.state.box' array so that later on in 'FaceRecognition.js' we can map over the array and have it generate the box (CSS lines).\n\n    // *** THE MAJOR FLAW RIGHT NOW: every time we click detect, it keeps pushing the values of the box into the this.state.box array, and it 'remembers' those values because it's in the same array that we later on, in 'FaceRecognition', map over to generate the box lines and so when we change URL (image), yes it will generate new boxes for the faces of the new picture, BUT it will also show the old boxes of the old faces of the old picture because the old values of the old boxes are still in the this.state.box array. \n      // so how do we make sure that every time we click detect, it's a fresh empty array that we're pushing the values in and mapping over to generate the face boxes?\n    }\n    \n    return this.state.box;\n    // after we looped and pushed the values of the box into the array 'this.state.box' (i.e. [0] (index 0) has bottomRow: 100, leftCol: 50, rightCol: 150, topRow: 200, then [1] ... for as many 'faces' as it detects) we want to return it\n  }\n\n  displayFaceBox = (boxValue) => {\n    console.log(boxValue);\n    this.setState({ box: boxValue });\n  }\n\n  onInputChange = (event) => {\n    this.setState({ input: event.target.value });\n  }\n\n  onButtonSubmit = () => {\n    this.setState({ imageUrl: this.state.input });\n    app.models\n      .predict(\n        Clarifai.DEMOGRAPHICS_MODEL, \n        this.state.input)\n      .then(response => this.displayFaceBox(this.calculateFaceLocation(response)))\n      .catch(err => console.log(err));\n        // .then(                         // check the breakdown of the nested object\n        //   function(response) {\n        //     console.log(response);\n        //   }\n        // )\n        // console.log('characteristics', response.outputs[0].data.regions[0].data.face);\n        // console.log('face box', response.outputs[0].data.regions[0].region_info.bounding_box);\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Particles className='particles'\n          params={particlesOptions}\n        />\n        <Navigation />\n        <Rank />\n        <ImageLinkForm \n          onInputChange={this.onInputChange} \n          onButtonSubmit={this.onButtonSubmit}\n        />\n        <FaceRecognition box={this.state.box} imageUrl={this.state.imageUrl}/> \n      </div>\n    );\n  }\n}\n\n// all the yellow tags are 'components/child' of the parent 'App' and the purple tags (besides className) are 'props/data' that are passed down to child components \n  // for example 'FaceRecognition' component has a 'box' prop which is {this.state.box}, in this case, the values that are passed are the values of the box (columns and rows) generated from the loop in calculateFaceLocation\n    // so if we check the 'FaceRecognition' component\n\nexport default App;\n\n// (1) since onInputChange is a part of the 'App' class, to access it, we need to do 'this.onInputChange' because onInputChange is a property of the 'App'\n"]},"metadata":{},"sourceType":"module"}